<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Screenshot Debug: 1920px (gradient-safe + logs)</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
<style>
  body{font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial;margin:20px auto;max-width:1100px}
  #url{width:420px;padding:6px;border:1px solid #ccc}
  button{padding:6px 10px;background:#4db760;color:#fff;border:0;border-radius:4px;cursor:pointer}
  #status{margin-top:10px;white-space:pre-line;color:#444}
  #screenshot{margin-top:16px;border:1px solid #ddd;display:inline-block;max-width:100%}
</style>
</head>
<body>
<h1>Screenshot Debug: 1920px (gradient-safe)</h1>
<input id="url" value="https://funkpd.com" />
<button id="go">Take Screenshot</button>
<div id="status"></div>
<div id="screenshot"></div>

<script>
const PROXY      = "https://testing2.funkpd.shop/cors.php";
const VIEW_WIDTH = 1920;

function log(msg, obj){
  const s = document.getElementById("status");
  const line = `[${new Date().toISOString()}] ${msg}`;
  if (obj!==undefined) { console.log(line, obj); s.textContent += line + " " + JSON.stringify(obj) + "\n"; }
  else { console.log(line); s.textContent += line + "\n"; }
  s.scrollTop = s.scrollHeight;
}

async function fetchSnapshot(url){
  const prox = `${PROXY}?url=${encodeURIComponent(url)}`;
  log("→ Fetching snapshot", {prox});
  const t0 = performance.now();
  const res = await fetch(prox);
  const dt = (performance.now() - t0).toFixed(1);
  log(`✓ Fetch ${res.status} in ${dt} ms`);
  if(!res.ok) throw new Error(`Proxy fetch ${res.status}`);
  const html = await res.text();
  log("✓ HTML bytes", {len: html.length});
  return html;
}

function buildIframe(width){
  const f = document.createElement("iframe");
  f.width = width;                 // define browsing context width
  f.height = 100;                  // temp; will resize to full height
  f.style.width  = width + "px";
  f.style.height = "100px";
  f.style.visibility = "hidden";   // hide but keep layout flow
  f.style.display = "block";
  f.style.border  = "0";
  document.body.appendChild(f);
  return f;
}

function writeHtmlIntoFrame(frame, html){
  const doc = frame.contentDocument || frame.contentWindow.document;
  doc.open(); doc.write(html); doc.close();
  return doc;
}

function rAF(){ return new Promise(r => requestAnimationFrame(r)); }

function freezeAnimations(doc){
  const st = doc.createElement("style");
  st.textContent = `*,*::before,*::after{animation:none!important;transition:none!important}`;
  (doc.head||doc.documentElement).appendChild(st);
}

async function settleFrame(doc){
  freezeAnimations(doc);
  await rAF(); await rAF();

  if (doc.fonts && doc.fonts.ready){
    try { await doc.fonts.ready; log("✓ Fonts ready"); }
    catch(e){ log("⚠ fonts.ready error"); }
  }

  // Robust image settling with 5s timeout per image
  const imgs = Array.from(doc.images || []);
  log(`→ Decoding ${imgs.length} images (5s timeout ea)`);
  await Promise.all(imgs.map((img,i)=>new Promise((resolve)=>{
    const src = img.currentSrc || img.src || "(no src)";
    const t0  = performance.now();
    const done = (tag)=>{ log(`✓ img#${i} ${tag}`, {src, ms:(performance.now()-t0).toFixed(1)}); resolve(); };
    const fail = (tag)=>{ log(`⚠ img#${i} ${tag}`, {src}); resolve(); };
    if (img.complete && img.naturalWidth > 0) return done("complete");
    let settled=false;
    const to=setTimeout(()=>{ if(!settled){ settled=true; fail("timeout"); }},5000);
    const cleanup=()=>clearTimeout(to);
    const onLoad =()=>{ if(!settled){ settled=true; cleanup(); done("decoded"); }};
    const onErr  =()=>{ if(!settled){ settled=true; cleanup(); fail("error");   }};
    if (img.decode) img.decode().then(onLoad).catch(onErr);
    else { img.addEventListener("load", onLoad, {once:true}); img.addEventListener("error", onErr, {once:true}); }
  })));
  log("✓ Image settle complete");
}

function measureViewport(frame, doc){
  const win = frame.contentWindow;
  const metrics = {
    innerWidth : win.innerWidth,
    clientWidth: doc.documentElement.clientWidth,
    bodyClient: doc.body ? doc.body.clientWidth : null
  };
  log("Viewport metrics", metrics);
  return metrics;
}

function computePageHeight(doc){
  const D = doc.documentElement, B = doc.body;
  const h = Math.max(D.scrollHeight, D.offsetHeight, B ? B.scrollHeight : 0);
  log("Computed doc height", {h});
  return h;
}

// ---- Gradient audit + guard ----
function auditGradients(doc){
  const els = doc.querySelectorAll("*");
  let seen = 0;
  for (const el of els){
    const bg = doc.defaultView.getComputedStyle(el).backgroundImage;
    if (bg && bg.includes("gradient(")) {
      log("gradient bg", {tag: el.tagName, class: el.className, bg: bg.slice(0,180)+"..."});
      if (++seen >= 30) break;
    }
  }
}

// Guard CanvasGradient.addColorStop to clamp invalid offsets (NaN/Inf/out-of-range)
(function patchAddColorStop(){
  try{
    const CG = CanvasGradient && CanvasGradient.prototype;
    if (!CG || CG.__patched__) return;
    const orig = CG.addColorStop;
    CG.addColorStop = function(offset, color){
      let v = Number(offset);
      if (!isFinite(v)) v = 0;
      if (v < 0) v = 0;
      if (v > 1) v = 1;
      const c = (typeof color === "string" && color) ? color : "rgba(0,0,0,0)";
      return orig.call(this, v, c);
    };
    CG.__patched__ = true;
    log("✓ Patched CanvasGradient.addColorStop guard");
  } catch(e){
    log("⚠ Failed to patch addColorStop (non-fatal)");
  }
})();

// Try canvas renderer; on addColorStop failure, retry with foreignObject
async function renderWithFallback(doc, width, height){
  const optsBase = {
    backgroundColor:"#fff",
    useCORS:true,
    allowTaint:false,
    scale:.5,
    windowWidth:width,
    windowHeight:height*.25,
    logging:false
  };
  try{
    log("→ html2canvas (canvas renderer) start");
    const c1 = await html2canvas(doc.documentElement, {...optsBase, foreignObjectRendering:false});
    log("✓ html2canvas (canvas) complete");
    return c1;
  } catch(e1){
    log("⚠ html2canvas (canvas) failed", {msg: e1 && e1.message});
    // Fallback path
    log("→ html2canvas (foreignObject) fallback start");
    const c2 = await html2canvas(doc.documentElement, {...optsBase, foreignObjectRendering:true});
    log("✓ html2canvas (foreignObject) complete");
    return c2;
  }
}

async function capture(url){
  document.getElementById("status").textContent = "";
  document.getElementById("screenshot").innerHTML = "";

  const html = await fetchSnapshot(url);

  log("→ Building iframe @1920");
  const frame = buildIframe(VIEW_WIDTH);
  let doc;
  try {
    doc = writeHtmlIntoFrame(frame, html);
    log("✓ HTML written to iframe");
    // Wait for load (with timeout)
    await new Promise((resolve)=>{ const to=setTimeout(()=>{ log("⚠ iframe load timeout (continuing)"); resolve(); },8000); frame.onload=()=>{ clearTimeout(to); log("✓ iframe onload"); resolve(); }; });

    await settleFrame(doc);
    auditGradients(doc);

    // Confirm viewport is actually 1920
    const vp = measureViewport(frame, doc);
    if (vp.innerWidth !== VIEW_WIDTH || vp.clientWidth !== VIEW_WIDTH) {
      log("⚠ Viewport mismatch; reassert width", vp);
      frame.width = VIEW_WIDTH; frame.style.width = VIEW_WIDTH + "px";
      await rAF(); await rAF();
      measureViewport(frame, doc);
    }

    const h = computePageHeight(doc);
    frame.height = h; frame.style.height = h + "px";

    const canvas = await renderWithFallback(doc, VIEW_WIDTH, h);
    document.getElementById("screenshot").appendChild(canvas);
    log(`✓ Done (${VIEW_WIDTH} × ${h})`);
  } finally {
    if (frame && frame.parentNode) frame.parentNode.removeChild(frame);
  }
}

document.getElementById("go").addEventListener("click", async ()=>{
  const u = document.getElementById("url").value.trim();
  if(!/^https?:\/\//i.test(u)) return alert("Enter full http(s) URL");
  try { await capture(u); }
  catch(e){ log("❌ Error: " + (e && e.message || e)); console.error(e); }
});
</script>
</body>
</html>
